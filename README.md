# Звіт з контейнеризації проєкту (Лабораторна робота №8)

**Студент:** Зрелко О.
**Група:** ІПЗ-22
**Варіант:** 11

## Огляд проєкту
Веб-застосунок "Krosy.ua" — це повнофункціональний інтернет-магазин кросівок, розроблений на фреймворку Flask.
**Функціональність включає:**
- Каталог товарів з фільтрацією та пошуком.
- Динамічну карусель популярних товарів (REST API).
- Систему відгуків користувачів.
- Оформлення замовлень із збереженням у базі даних.
- Адміністративну панель (опціонально).

## Архітектура контейнерного рішення

### Docker образ
- **Базовий образ:** `python:3.11-slim` (Debian-based).
- **Розмір фінального образу:** ~180 MB.
- **Використання багатоетапної збірки:** Так.
  - *Етап 1 (Builder):* Встановлення залежностей та компіляція бібліотек.
  - *Етап 2 (Final):* Копіювання лише необхідних файлів та віртуального оточення.

### Docker Compose
- **Кількість сервісів:** 1 (`sneaker_store_backend`).
- **Порти:** Зовнішній порт `5000` прокидається на внутрішній `5000`.
- **Використовувані volumes:**
  - `sqlite_data:/app/data` (або `./instance:/app/instance`) — для збереження файлу бази даних `db.sqlite`. Це гарантує, що при перезапуску контейнера відгуки та замовлення не зникають.

## Прийняті рішення та обґрунтування

### Вибір базового образу
Було обрано образ **`python:3.11-slim`** замість `alpine`.
**Обґрунтування:** Хоча `alpine` теоретично менший, він використовує бібліотеку `musl` замість `glibc`, що часто викликає проблеми сумісності з деякими Python-пакетами (wheels) і вимагає довгої компіляції. Образ `slim` забезпечує найкращий баланс між розміром, стабільністю та швидкістю збірки.

### Організація збереження даних
База даних SQLite — це файл. У контейнері файлова система є ефемерною (тимчасовою).
Щоб уникнути втрати даних при перезапуску контейнера, використано механізм **Docker Volumes**. Файл бази даних монтується із хост-машини всередину контейнера.

### Оптимізації
1. **Багатоетапна збірка (Multi-stage build):** Дозволила не тягнути у фінальний образ кеш `pip` та інструменти компіляції, залишивши тільки чистий Python та необхідні бібліотеки.
2. **.dockerignore:** Налаштовано ігнорування папок `__pycache__`, `.git` та віртуального оточення `venv` при копіюванні, що пришвидшує контекст збірки.
3. **Змінні оточення:** Використано `PYTHONUNBUFFERED=1` для того, щоб логи Flask виводились у консоль Docker миттєво без буферизації.

## Інструкції з розгортання

Для запуску проєкту на будь-якому комп'ютері зі встановленим Docker необхідно виконати наступні кроки:

1. **Клонувати репозиторій:**
   ```bash
   git clone <посилання-на-repo>
   cd sneaker_store
Запустити проект через Docker Compose:

Bash

docker compose up --build
Прапорець --build гарантує, що образ буде зібрано з актуального коду.

Відкрити у браузері: Перейти за посиланням: http://localhost:5000

Зупинити проект:

Bash

docker compose down
Можливі покращення
Перехід на PostgreSQL: Для високого навантаження замінити SQLite на PostgreSQL, додавши його як окремий сервіс у docker-compose.yml.

Nginx Reverse Proxy: Додати контейнер з Nginx перед Flask для обробки статичних файлів та SSL-шифрування.

CI/CD: Налаштувати автоматичну збірку Docker-образу при пуші в GitHub.

Висновки
У ході виконання лабораторної роботи було успішно контейнеризовано веб-застосунок "Krosy.ua". Використання Docker дозволило вирішити проблему "це працює на моєму комп'ютері", забезпечивши ідентичне середовище для розробки та запуску. Я навчився писати оптимальні Dockerfile, керувати багатоконтейнерними додатками через docker-compose та працювати з персистентними даними (Volumes).